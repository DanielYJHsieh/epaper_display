# 圖像傳輸問題診斷報告

**日期**: 2025-10-07  
**版本**: v1.2.2  
**問題**: 圖像傳輸導致 ESP8266 斷線重啟

---

## 🐛 問題現象

### 觀察到的行為

1. **Text 模式正常**：測試圖案（test pattern）可以正常顯示
2. **Image 模式失敗**：發送 `test.jpg` 後 ESP8266 立即斷線重啟

### 日誌分析

```
原始資料: 12000 bytes
壓縮後: 21862 bytes (壓縮率: -82.2%)  ← ❌ 負壓縮率！
封包大小: 21870 bytes (含標頭)
```

**關鍵發現**：
- 壓縮後資料 **比原始資料大 82%**！
- RLE 壓縮完全失效
- 封包大小達到 21.8KB

---

## 🔍 根本原因分析

### 1. RLE 壓縮失效

**RLE (Run-Length Encoding) 適用場景**：
- ✅ 大面積相同顏色區域（如測試圖案、文字、QR code）
- ✅ 簡單圖形、線條、框架
- ❌ 複雜照片、漸層、紋理

**為什麼會壓縮失敗？**

當圖像轉換為 1-bit 黑白後，如果產生大量黑白交替的像素模式：

```
原始（每 byte 8 個像素）: 01010101 01010101 ...
RLE 壓縮（每個 run 2 bytes）: [1,0] [1,1] [1,0] [1,1] ...

結果：8 pixels 原本 1 byte → RLE 後 8 bytes！
```

### 2. 記憶體壓力

**當前記憶體需求**：
```
接收緩衝：21,862 bytes (壓縮資料)
解壓緩衝：12,000 bytes (原始圖像)
───────────────────────────────
總需求：  33,862 bytes

ESP8266 可用：~45,000 bytes
安全餘量：~11,000 bytes (24%)  ← 非常緊張！
```

### 3. WebSocket 處理瓶頸

**問題鏈條**：
1. 伺服器一次性發送 21.8KB 資料
2. ESP8266 需要 malloc 21.8KB 接收緩衝
3. 加上解壓緩衝 12KB，總共 ~34KB
4. 記憶體碎片化後，無法分配
5. 程式崩潰或看門狗重啟

---

## ✅ 已實施的改進

### 1. 記憶體檢查 (`protocol.h`)

```cpp
// 分配前檢查
if (freeHeap < header.length + 8000) {  // 保留 8KB 安全餘量
  Serial.println(F("記憶體不足！"));
  return false;
}
```

### 2. 看門狗餵食

```cpp
// protocol.h - 接收時
yield();  // 每次 memcpy 後

// rle_decoder.h - 解壓縮時  
if ((inPos % 512) == 0) {
  yield();  // 每 512 bytes 餵食一次
}
```

### 3. 詳細日誌

```cpp
Serial.print(F("需要分配: "));
Serial.print(header.length);
Serial.print(F(" bytes, 可用: "));
Serial.print(freeHeap);
Serial.println(F(" bytes"));
```

---

## 📋 測試結果（預期）

### 測試 1: 簡單測試圖案 (test pattern)
```
✅ 狀態: 正常工作
原始: 12000 bytes
壓縮: ~1300 bytes (壓縮率: 89%)
記憶體: 充足（1.3KB + 12KB = 13.3KB）
```

### 測試 2: 複雜照片 (test.jpg)
```
❌ 狀態: 失敗（當前）
原始: 12000 bytes
壓縮: 21862 bytes (壓縮率: -82%)
記憶體: 不足（21.8KB + 12KB = 33.8KB）
預期結果: ESP8266 斷線或記憶體分配失敗
```

---

## 💡 解決方案

### 方案 1: 使用簡單圖像 ⭐ 推薦（短期）

**適合 400×240 + RLE 的圖像類型**：
- ✅ 文字、字幕
- ✅ QR Code、條碼
- ✅ Logo、圖標
- ✅ 簡單圖形、線條
- ✅ 卡通風格圖像
- ❌ 照片、漸層

**測試方法**：
```python
# 建立簡單測試圖像
from PIL import Image, ImageDraw, ImageFont

img = Image.new('1', (400, 240), 1)  # 白背景
draw = ImageDraw.Draw(img)
draw.rectangle([20, 20, 380, 220], outline=0, width=3)
draw.text((150, 100), "Hello World!", fill=0)
img.save("simple_test.png")
```

然後在伺服器輸入：
```bash
>>> image simple_test.png
```

### 方案 2: 改進壓縮演算法 （中期）

**替代 RLE 的選項**：

1. **無壓縮模式**（最簡單）
   - 直接傳輸 12KB 原始資料
   - 適合簡單圖像
   - 記憶體需求：12KB

2. **分塊傳輸**（推薦）
   - 將 400×240 分成 4 塊（每塊 60 行）
   - 每塊只需 3KB
   - 分 4 次傳輸
   - 記憶體需求：3KB（降低 75%）

3. **使用更好的壓縮**
   - PNG 壓縮（需要額外函式庫）
   - LZ4 壓縮（快速但需要更多 RAM）

### 方案 3: 實作分塊傳輸協議 （長期）

**設計新協議**：

```cpp
// 新封包類型
CHUNK_UPDATE = 0x03  // 分塊更新

// 封包格式
struct ChunkPacket {
  uint8_t type;      // CHUNK_UPDATE
  uint16_t seqId;    // 序號
  uint8_t chunkId;   // 塊編號 (0-3)
  uint8_t totalChunks; // 總塊數 (4)
  uint32_t length;   // 資料長度 (~3KB)
  uint8_t data[];    // 壓縮資料
}
```

**優點**：
- 每次只需 3-4KB 記憶體
- 避免大塊分配
- 可靠性更高

---

## 🧪 當前測試建議

### 立即可測試

1. **使用測試圖案**（應該正常）
   ```bash
   >>> t
   ```

2. **建立簡單圖像測試**
   ```python
   # 在 Python 中
   from PIL import Image, ImageDraw
   
   img = Image.new('RGB', (400, 240), 'white')
   draw = ImageDraw.Draw(img)
   
   # 繪製簡單圖形
   draw.rectangle([50, 50, 350, 190], outline='black', width=5)
   draw.text((150, 100), "ESP8266 Test", fill='black')
   
   img.save('simple.jpg')
   ```
   
   然後測試：
   ```bash
   >>> image simple.jpg
   ```

### 檢查壓縮率

**好的壓縮率**：
- 測試圖案：~90% （12KB → 1.2KB）✅
- 簡單圖像：70-90% （12KB → 1.2-3.6KB）✅  
- QR Code：95%+ （12KB → <600 bytes）✅

**差的壓縮率**：
- 複雜照片：-50% to -100% （12KB → 18-24KB）❌
- 漸層圖：-30% to -70% （12KB → 15-20KB）❌

---

## 📊 記憶體使用對比

| 圖像類型 | 壓縮後大小 | 接收緩衝 | 解壓緩衝 | 總需求 | 可用度 |
|---------|-----------|---------|---------|--------|-------|
| **測試圖案** | 1.3KB | 1.3KB | 12KB | 13.3KB | ✅ 充足 |
| **簡單圖像** | 3-4KB | 4KB | 12KB | 16KB | ✅ 安全 |
| **QR Code** | 0.6KB | 0.6KB | 12KB | 12.6KB | ✅ 優秀 |
| **複雜照片** | 21.8KB | 21.8KB | 12KB | 33.8KB | ❌ 緊張 |

---

## 🔧 下一步行動

### 立即（測試當前改進）

1. ✅ 已添加記憶體檢查
2. ✅ 已添加看門狗餵食
3. ⏳ 上傳新韌體到 ESP8266
4. ⏳ 使用簡單圖像測試

### 短期（1-2 天）

1. 建立圖像預處理腳本
   - 檢查壓縮率
   - 警告複雜圖像
   - 建議圖像優化

2. 添加無壓縮模式
   - 對於小於 12KB 的簡單圖像
   - 跳過 RLE 壓縮
   - 直接傳輸

### 中期（1 週）

1. 實作分塊傳輸協議
   - 新封包類型 CHUNK_UPDATE
   - 分 4 塊傳輸（每塊 3KB）
   - 記憶體需求降低 75%

2. 改進伺服器壓縮策略
   - 自動選擇壓縮方式
   - 比較 RLE vs 無壓縮
   - 選擇較小的方式

---

## 📝 程式碼修改記錄

### v1.2.2 (2025-10-07)

**修改檔案**：
1. `protocol.h`:
   - 添加記憶體檢查（8KB 安全餘量）
   - 添加 yield() 防止看門狗
   - 添加詳細日誌

2. `rle_decoder.h`:
   - 解壓縮時每 512 bytes 餵食看門狗
   - 防止長時間處理導致重啟

3. `client_esp8266.ino`:
   - 添加 WebSocket 緩衝區註解

---

## ✅ 結論

**當前狀態**：
- ✅ 系統架構正確
- ✅ 測試圖案正常工作  
- ❌ 複雜圖像記憶體不足

**建議**：
1. **立即**：使用簡單圖像（文字、QR code、簡單圖形）
2. **短期**：添加壓縮率檢查和警告
3. **長期**：實作分塊傳輸協議

**適用場景**：
- ✅ 資訊顯示（天氣、時間、通知）
- ✅ QR Code 顯示
- ✅ 簡單UI、選單
- ❌ 照片顯示
- ❌ 複雜圖像

ESP8266 + 400×240 + RLE 最適合**簡單圖形和文字顯示**的應用場景。
