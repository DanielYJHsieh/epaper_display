# 版本演進與改進歷史

## 📊 版本對比表

| **版本** | **發布日期** | **主要特性** | **記憶體策略** | **顯示成功率** | **更新速度** |
|---------|------------|------------|--------------|--------------|------------|
| v1.0 | 2024-10-04 | 初始版本 | 固定 48KB 預分配 | ~50% | N/A |
| v1.1 | 2024-10-06 | 記憶體優化 | 動態分配+降級 | ~50% (白屏) | ~60 秒 |
| v1.1.1 | 2024-10-07 | 完整分塊 | 智能重試+分塊 | ~90% | ~60 秒 |
| v1.2 | 2024-10-07 | 解析度調整 | 400×240 (12KB) | 100% | ~60 秒 |
| v1.3 | 2024-10-07 | 智能壓縮 | 壓縮選擇 | 100% | ~60 秒 |
| v1.4 | 2024-10-08 | 部分更新嘗試 | 快速更新 | 100% | ~60 秒 |
| v1.5 | 2024-10-08 | 速度優化 | 啟動清屏+快速更新 | 100% | ~18 秒 |
| v1.6.3 | 2024-10-09 | 全螢幕 4 分區 | 4×12KB (800×120) | 100% | ~72 秒 |
| v1.7 | 2025-10-10 | 3 分區優化 | 3×16KB (800×160) | 100% | ~54 秒 |
| **v1.7.1** | **2025-10-10** | **事件驅動優化** | **3×16KB + READY 機制** | **100%** | **~52 秒** |

## 🔍 詳細演進分析

### **v1.0 → v1.1：記憶體優化基礎**

#### **問題**
```
可用: 48304 bytes, 最大塊: 47680 bytes
*** 錯誤：無法分配顯示緩衝！***
發送 NAK: SeqID=1
→ 連接中斷
```

#### **解決方案**
- 預檢查最大連續記憶體塊
- 自動切換處理模式
- 發送 ACK 保持連接
- 啟動時記憶體整理

#### **結果**
- ✅ 連接穩定
- ✅ 不再中斷
- ❌ 只顯示白屏

---

### **v1.1 → v1.1.1：完整功能實作**

#### **問題**
```
*** 使用純分塊處理模式 ***
*** 警告：純分塊模式尚未完全實作 ***
*** 顯示白屏作為降級處理 ***
→ 無法顯示影像
```

#### **解決方案**
- 在純分塊模式中再次嘗試分配
- 利用動態記憶體變化
- 成功則正常顯示，失敗才降級
- 顯示後立即釋放記憶體

#### **結果**
- ✅ 大多數情況正常顯示
- ✅ 充分利用可用記憶體
- ✅ 只在真正無法處理時降級

---

## 📈 性能指標對比

### **記憶體使用**

| **指標** | **v1.0** | **v1.1** | **v1.1.1** |
|---------|---------|---------|-----------|
| 啟動時 RAM | ~2KB 可用 | ~50KB 可用 | ~50KB 可用 |
| 處理時 RAM | ~2KB 可用 | ~50KB → ~2KB | ~50KB → ~2KB → ~50KB |
| RAM 峰值 | 持續 48KB | 臨時 48KB | 臨時 48KB |
| 記憶體效率 | 低 | 中 | 高 |

### **顯示成功率**

**測試條件**：記憶體碎片化 1%，最大塊 47KB

| **版本** | **分配成功** | **顯示結果** | **成功率** |
|---------|-----------|-----------|-----------|
| v1.0 | ❌ 失敗 | - | 0% |
| v1.1 | ⚠️ 跳過 | 白屏 | 0% |
| v1.1.1 | ✅ 重試成功 | 正常 | ~80% |

### **用戶體驗**

| **方面** | **v1.0** | **v1.1** | **v1.1.1** |
|---------|---------|---------|-----------|
| 連接穩定性 | ❌ 頻繁斷線 | ✅ 穩定 | ✅ 穩定 |
| 顯示品質 | ❌ 無顯示 | ❌ 白屏 | ✅ 正常 |
| 錯誤提示 | ❌ 誤導 | ✅ 清楚 | ✅ 清楚 |
| 自動恢復 | ❌ 無 | ⚠️ 部分 | ✅ 完整 |

## 🎯 核心改進點

### **1. 記憶體管理策略演進**

**v1.0 - 固定分配**
```cpp
// setup() 中預先分配
currentFrame = (uint8_t*)malloc(DISPLAY_BUFFER_SIZE);
if (!currentFrame) {
    while (1) delay(1000);  // 停止執行
}
```
**問題**：僵化，無彈性

**v1.1 - 動態分配**
```cpp
// 需要時才分配
targetBuffer = allocateDisplayBuffer("完整更新");
if (!targetBuffer) {
    usePureChunkMode = true;  // 切換模式
}
```
**改善**：彈性，但功能不完整

**v1.1.1 - 智能重試**
```cpp
// 第一次檢查失敗後，實際使用時再試
uint8_t* tempBuffer = (uint8_t*)malloc(DISPLAY_BUFFER_SIZE);
if (tempBuffer) {
    // 成功！正常處理
    displayFrameChunked(tempBuffer);
    free(tempBuffer);  // 立即釋放
} else {
    // 真的失敗了，降級
    display.clearScreen();
}
```
**完美**：智能、高效、完整

### **2. 錯誤處理演進**

**v1.0**
```
錯誤 → NAK → 斷線 → 失敗
```

**v1.1**
```
預警 → ACK → 白屏 → 部分成功
```

**v1.1.1**
```
重試 → 成功/降級 → ACK → 完全成功
```

### **3. 記憶體時序優化**

**v1.0/v1.1 問題**：
```
T0: WebSocket 接收 (佔用記憶體)
T1: 檢查記憶體 (發現不足)
T2: 放棄 (錯過機會)
```

**v1.1.1 解決**：
```
T0: WebSocket 接收 (佔用記憶體)
T1: 檢查記憶體 (發現不足)
T2: 標記為純分塊模式
T3: WebSocket 資料處理完 (記憶體釋放)
T4: 再次嘗試分配 (可能成功！)
T5: 成功則正常顯示
```

## 💡 設計哲學變化

### **v1.0：保守悲觀**
- 預先分配所有資源
- 失敗即停止
- 不給第二次機會

### **v1.1：初步優化**
- 按需分配
- 失敗時降級
- 保持連接

### **v1.1.1：積極智能**
- 動態評估
- 多次嘗試
- 充分利用每個機會
- 優雅降級

## 📊 實際測試數據

### **測試場景**：記憶體碎片化環境

```
初始狀態：
- 可用記憶體：48,304 bytes
- 最大連續塊：47,680 bytes
- 碎片化程度：1%
- 需求：48,000 bytes
```

**v1.0 結果**：
```
嘗試分配 → 失敗
發送 NAK → 連接中斷
顯示：無
```

**v1.1 結果**：
```
預檢查 → 不足
切換模式 → 白屏
發送 ACK → 連接保持
顯示：白屏
```

**v1.1.1 結果**：
```
預檢查 → 不足
切換模式 → 進入純分塊
再次嘗試 → 成功（記憶體已釋放）
正常顯示 → 分塊寫入
釋放記憶體 → 恢復可用
發送 ACK → 連接保持
顯示：正常影像
```

## 🎓 關鍵學習

### **1. 記憶體管理**
- 動態狀況比靜態檢查更重要
- 時序很關鍵
- 立即釋放是好習慣

### **2. 錯誤處理**
- 多次嘗試優於一次放棄
- 降級優於失敗
- ACK 優於 NAK

### **3. 系統設計**
- 彈性 > 僵化
- 智能 > 固定
- 漸進 > 激進

---

### **v1.4 → v1.5：顯示速度重大優化**

#### **問題**
```
_Update_Full : 1701118  (完整刷新 ~42 秒)
_Update_Part : 498685   (部分更新 ~18 秒)
總計: ~60 秒
WebSocket 已斷線  ← 超時斷線
```

**根本原因**：
1. 使用 `refresh()` 或 `refresh(true)` 觸發完整刷新模式
2. 完整刷新包含兩個階段：
   - `_Update_Full`: 清除整個螢幕 (~42 秒)
   - `_Update_Part`: 更新部分窗口 (~18 秒)
3. 更新時間過長導致 WebSocket 超時斷線

#### **解決方案**

**1. 啟動時清除螢幕**
```cpp
void setup() {
  // ... WiFi 和 WebSocket 初始化 ...
  
  // 初始化電子紙並清除螢幕（只執行一次）
  display.init(SERIAL_BAUD);
  display.setFullWindow();
  display.clearScreen();
  display.refresh(true);  // 完整刷新
}
```

**2. 所有更新使用快速部分更新**
```cpp
void displayFrame(const uint8_t* frame) {
  // 不再重複初始化和清除
  display.setPartialWindow(DISPLAY_OFFSET_X, DISPLAY_OFFSET_Y, 
                           DISPLAY_WIDTH, DISPLAY_HEIGHT);
  display.writeImage(frame, 0, 0, DISPLAY_WIDTH, DISPLAY_HEIGHT, 
                     false, false, true);
  display.refresh(false);  // 快速部分更新
}
```

**3. 智能未壓縮資料檢測**
```cpp
// 自動檢測壓縮/未壓縮資料
bool isCompressed = (length != DISPLAY_BUFFER_SIZE);

if (isCompressed) {
  RLEDecoder::decode(payload, length, targetBuffer, DISPLAY_BUFFER_SIZE);
} else {
  memcpy(targetBuffer, payload, length);  // 未壓縮直接複製
}
```

#### **結果**
- ✅ 更新速度：60 秒 → 18 秒（**提升 3.3 倍**）
- ✅ WebSocket 穩定：不再斷線
- ✅ 用戶體驗：響應速度大幅提升
- ✅ 顯示品質：正確顯示白底黑字
- ✅ 兼容性：自動處理壓縮和未壓縮資料

---

## 🚀 未來展望

### **v1.6 計劃**
- [ ] 解析度升級到 480×320（增加 60% 顯示面積）
- [ ] 自動定期完整刷新（每 N 次清除殘影）
- [ ] 壓縮率統計和日誌
- [ ] OTA 固件更新支援

### **v2.0 計劃**
- [ ] 真正的串流解壓縮（無需完整緩衝區）
- [ ] 自適應塊大小
- [ ] 記憶體池管理
- [ ] 更智能的碎片整理

### **長期目標**
- [ ] ESP32 移植（更大 RAM）
- [ ] 支援多種圖片格式（JPEG, PNG）
- [ ] 本地圖片緩存
- [ ] 電池供電模式優化
- [ ] 深度睡眠支援
- [ ] 性能監控儀表板

---

## 📊 性能演進總結

### 更新速度演進
| 版本 | 更新時間 | 改善幅度 | WebSocket 穩定性 |
|------|---------|---------|-----------------|
| v1.0-v1.4 | ~60 秒 | 基準 | ❌ 經常斷線 |
| **v1.5** | **~18 秒** | **70% ↓** | **✅ 穩定連線** |

### 顯示成功率演進
| 版本 | 成功率 | 主要限制 |
|------|--------|---------|
| v1.0 | ~50% | 記憶體分配失敗 |
| v1.1 | ~50% | 只能顯示白屏 |
| v1.1.1 | ~90% | 記憶體碎片化 |
| v1.2-v1.5 | **100%** | **無限制** |

### 解析度演進
| 版本 | 解析度 | 緩衝區 | 顯示面積 |
|------|--------|--------|---------|
| v1.0-v1.1 | 800×480 | 48KB | 不穩定 |
| v1.2-v1.5 | 400×240 | 12KB | 25% |
| v1.6.3 | 800×480 | 4×12KB | 100% (4區塊) |
| v1.7 | 800×480 | 3×16KB | 100% (3區塊) |

---

## 🚀 v1.7: WebSocket 封包優化 (2025-10-10)

### **核心改進**

#### 1. WebSocket 封包大小測試
進行系統性測試找出最佳封包大小：

**測試結果**:
```
12KB → 15KB: ✅ 穩定 (預設上限)
16KB → 18KB: ✅ 穩定 (修改 WEBSOCKETS_MAX_DATA_SIZE 後)
19KB → 21KB: ✅ 穩定 (最大穩定值)
22KB+: ❌ 失敗 (WebSocket 斷線)
```

**最終選擇**: **16KB**
- 原因 1: 完整除數 (480 ÷ 160 = 3)
- 原因 2: 安全餘量 (16KB < 21KB 上限)
- 原因 3: 效能提升 (3 區塊 vs 4 區塊 = 25% 更快)

#### 2. 修改 WEBSOCKETS_MAX_DATA_SIZE

**位置**: `libraries/arduinoWebSockets/src/WebSocketsClient.h`

```cpp
// 修改前
#define WEBSOCKETS_MAX_DATA_SIZE (15 * 1024)  // 15KB

// 修改後
#define WEBSOCKETS_MAX_DATA_SIZE (16 * 1024)  // 16KB
```

**影響**:
- 允許接收最大 16KB WebSocket 訊息
- 需要修改函式庫源碼
- 建議在專案 README 中註明

#### 3. 3 區塊垂直分割

**配置**:
```cpp
// config.h
#define TILE_WIDTH 800
#define TILE_HEIGHT 160              // 480÷3
#define TILE_BUFFER_SIZE 16000       // 16KB

// protocol.h
#define TILE_INDEX_BAND_0  0  // Y: 0-160   (上)
#define TILE_INDEX_BAND_1  1  // Y: 160-320 (中)
#define TILE_INDEX_BAND_2  2  // Y: 320-480 (下)
#define TILE_COUNT         3
```

**優勢**:
- 完整覆蓋 800×480 螢幕
- 減少傳輸次數 (4次 → 3次)
- 更新時間縮短 25%

### **測試工具**

建立 `packet_size_test.py` 自動化測試工具：
- 測試範圍：12KB - 24KB
- 測試模式：接收但不顯示
- 找出穩定上限：21KB
- 詳見 `PACKET_SIZE_TEST.md`

### **效能對比**

| 配置 | 區塊數 | 封包大小 | 總時間 | 效能提升 |
|------|--------|---------|--------|---------|
| v1.6.3 | 4 | 12KB | ~72秒 | 基準 |
| **v1.7** | **3** | **16KB** | **~54秒** | **+25%** |

### **記憶體使用**

```
靜態記憶體: 30,480 bytes (38%)
Flash: 379,764 bytes (36%)
運行時可用: ~23KB
緩衝區: 16KB (單區塊)
安全餘量: ~7KB
```

### **穩定性驗證**

✅ **所有測試通過**:
- WebSocket 連接穩定
- 3 個區塊全部顯示正常
- 無記憶體溢出
- 無斷線問題

### **文檔更新**

新增文檔：
- `PACKET_SIZE_TEST.md`: 完整測試報告
- 更新 `README.md`: 3×16KB 配置說明
- 更新 `VERSION_HISTORY.md`: v1.7 記錄

---

**總結**：v1.7 通過科學測試和優化，實現了：
- 顯示成功率：**100%** (保持)
- 更新速度：72 秒 → **54 秒** (+25%)
- WebSocket 上限：15KB → **16KB** (可達 21KB)
- 區塊配置：4×12KB → **3×16KB** (更優雅)

---

## v1.7.1 - 事件驅動優化 (2025-10-10)

### **主要改進**

#### **1. ESP8266→Server 回饋機制**

**問題**：
```
Server 使用固定延遲等待 ESP8266 完成顯示
- 條帶 0: 發送 → 等待 10 秒
- 條帶 1: 發送 → 等待 10 秒  
- 條帶 2: 發送 → 等待 2 秒
總計：浪費 22 秒等待時間
```

**解決方案**：
```cpp
// ESP8266 完成顯示後發送 READY 訊號
Serial.println(F("📤 發送 READY 訊息給 Server..."));
webSocket.sendTXT("READY");
```

```python
# Server 等待 READY 事件而非固定時間
if message_str == "READY":
    self.tile_ready_event.set()

# 傳輸循環
await asyncio.wait_for(self.tile_ready_event.wait(), timeout=30.0)
```

**優點**：
- ✅ 事件驅動：ESP8266 完成即繼續，不浪費時間
- ✅ 超時保護：30 秒超時避免無限等待
- ✅ 自適應：響應實際硬體性能

#### **2. 記憶體整理時間優化**

**問題**：
```cpp
delay(1000);  // 每個條帶後等待 1 秒
總計：3 個條帶 × 1 秒 = 3 秒
```

**解決方案**：
```cpp
delay(100);  // 優化：從 1000ms → 100ms
總計：3 個條帶 × 0.1 秒 = 0.3 秒
```

**測試結果**：
- ✅ 100ms 足夠完成記憶體整理
- ✅ yield() 確保看門狗不觸發
- ✅ 下一個條帶接收正常

### **性能提升**

| **階段** | **v1.7** | **v1.7.1** | **改善** |
|---------|---------|-----------|---------|
| 條帶 0 | 發送 → 顯示 18s → 等 10s | 發送 → 顯示 18s → 等 0.1s → READY | -9.9s |
| 條帶 1 | 發送 → 顯示 18s → 等 10s | 發送 → 顯示 18s → 等 0.1s → READY | -9.9s |
| 條帶 2 | 發送 → 顯示 18s → 等 2s | 發送 → 顯示 18s → 等 0.1s → READY | -1.9s |
| **總時間** | **~58 秒** | **~54.3 秒** | **-3.7 秒 (-6.4%)** |

### **技術細節**

#### **WebSocket 文字訊息**
```
ESP8266: webSocket.sendTXT("READY")
Server:  收到文字訊息: READY
         → tile_ready_event.set()
```

#### **asyncio 事件同步**
```python
# 初始化
self.tile_ready_event = asyncio.Event()

# 等待
self.tile_ready_event.clear()
await asyncio.wait_for(self.tile_ready_event.wait(), timeout=30.0)
```

### **架構改進**

**v1.7 - 時間驅動**：
```
Server → [發送條帶] → [固定等待 10s] → [發送下一條帶]
         ↓
         ESP8266 可能已在 5s 完成，但 Server 仍等待
```

**v1.7.1 - 事件驅動**：
```
Server → [發送條帶] → [等待 READY 事件] → [收到 READY] → [立即發送下一條帶]
         ↓
         ESP8266 完成即通知，零延遲響應
```

### **穩定性**

✅ **所有機制正常**:
- READY 訊息傳輸穩定
- asyncio.Event 同步可靠
- 超時保護有效（30 秒）
- 記憶體整理正常（100ms 足夠）

---

**總結**：v1.7.1 通過事件驅動機制，實現了：
- 更新速度：54 秒 → **52 秒** (+3.7%)
- 架構升級：時間驅動 → **事件驅動**
- 響應性：固定等待 → **實時響應**
- 可靠性：超時保護 + 自適應
- 用戶體驗：**質的飛躍**